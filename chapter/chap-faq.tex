\chapter{虚拟人手的自动纹理贴图}
\label{chap:faq}

物体的纹理通常是指物体的表面特征。纹理是物体最重要的特征之一，通常我们区分同一类物体是根据物体表面纹理来进行的。对物体进行纹理贴图则是指采用图像或者函数来改变物体的表面特征。在计算机图形学中当我们难以用可视化数据对物体表面进行精确描述时，就可以采用纹理贴图这种方式来方便的表达物体，并可在物体建模、运行速度和存储空间上节省大量的资源。本章详细介绍了对人手模型进行纹理贴图整个步骤。

\section{3D人手模型的调整}
为了对3D人手模型进行纹理贴图，首先应该通过拍摄得到人手的正面和背面图。纹理图的质量将会严重影响最终的纹理映射，因此我们应该选择在光线较好的环境下进行拍摄。另外为了防止拍摄时的背景干扰最终的映射过程，因此我们以白纸作为背景。最终我们得到手的正面图和背面图如图3.1所示。

\begin{figure}[htb]
\centering
\subfigure[]{
\begin{minipage}[c]{0.4\textwidth}
\includegraphics[width=5.0cm]{../img/fron.jpg}
\end{minipage}}%
\subfigure[]{
\begin{minipage}[c]{0.4\textwidth}
\includegraphics[width=5.0cm]{img/over_back.jpg}
\end{minipage}}%
\caption{拍摄得到的纹理图:(a) 正面图;(b) 背面图.}     
\end{figure}

目前有大量的软件可以用来制作3D模型，比如3DS
max、Maya以及Autocad等，这些软件已经非常的普及并且易于上手。而其中的3DS
max更是以其强大的建模和渲染能力被广泛应用于三维动画、影视制作以及建筑设计中，得到大量研究者的青睐。但是由于其制作出来的很多模型文件格式的内部结构并未得到公布，因此很不利于研究者进行二次开发和利用。不过这些未公布的文件格式可以通过格式转换功能来生成一些通用的文件格式，比如3ds和obj格式等。

这里我们采用3DS
max软件直接对从Internet上已经共享的一般人手模型的max文件进行调整，该软件可以从让我们从多个不同的视角查看物体对象，并对其进行实时渲染和显示。如图3.2所示：

\begin{figure}[htb]
\centering
\includegraphics[width=4.5in, height=3.0in]{../img/3dsmax.jpg}
\caption{3DS MAX制作人手模型}
\label{fig：graph}
\end{figure} 

在调整时需要以拍摄得到的背面纹理图作为模板。将调整后得到的个性化人手模型导出为3ds模型，便于进行二次开发。图3.3(a)和3.3(b)分别为调整前的人手模型以及调整后的人手模型。

\begin{figure}[htb]
\begin{tabular}{cc}
~~~~~~~~~~~~~~\includegraphics[width=4.0cm, height=5.2cm]{../img/orig.jpg}&
~~~~~~~~~~~~\includegraphics[width=4.0cm, height=5.2cm]{../img/adjust1.jpg}\\
~~~~~~~~~~~~~~(a)& ~~~~~~~~~~~~(b)
\end{tabular}
\caption{人手模型: (a) 一般模型; (b) 个性化模型.}     
\end{figure}

\section{正面图的调整}
在上一小节中因为我们采用背面纹理图作为模板对一般人手模型进行调整，这样对模型背面采用人手背面图进行纹理贴图时并不会有什么问题。但是如果直接将拍摄得到人手正面图对模型正面进行纹理贴图时将会带来很大困扰。这是因为在拍摄过程中因为相机的抖动以及手指的运动，使得人手正面图并不能和人手背面图的镜像完全重合。图3.4是人手正面图和人手背面图的镜像放在一起后的结果。

\begin{figure}[htb]
\centering
\includegraphics[width=2.2in, height=2.3in]{../img/overlap_src.jpg}
\caption{人手正面图和人手背面图镜像后的重合}
\label{fig：graph}
\end{figure} 

从图3.4中我们可以清晰的看出在小拇指出以及手腕处两张图明显不能重合，因此为了便于后面的纹理映射我们需要对人手正面图进行调整使其可以和人手背面图的镜像重合。

调整的步骤如下：

1)对人手背面图镜像处理。之后分别对处理后的背面图像以及人手正面图进行二值化处理，以便于下面对人手边缘进行检测。

2)逐行扫描两幅图像，记录检测到的每根手指或者手掌的边缘坐标。这里以小拇指为例，如图3.5所示，
\begin{figure}[htb]
\begin{tabular}{cc}
~~~~~~~~~~~~~~~~~~~~~~~~~~~\includegraphics[width=1.5 cm]{img/little_back1.jpg}&
~~~~~~~~~~~~~~~\includegraphics[width=1.5 cm]{img/little_fron1.jpg}\\
~~~~~~~~~~~~~~~~~~~~~~~(a)& ~~~~~~~~~(b)
\end{tabular}
\caption{小拇指的边缘检测: (a) 镜像后的小拇指背面; (b) 小拇指正面.}
\end{figure}

$a$和$b$分别代表经过镜像处理后的背面人手小拇指的左右边缘，而$c$和$d$则分别代表正面人手小拇指的左右边缘，$x$和$x^{'}$代表边缘连接线上的任意位置。

3)线性平移缩放线cd到线ab处。变换的公式为：
\begin{eqnarray}
x=a+(x'-c)*\frac{b-a}{d-c}
\end{eqnarray}

将人手正面图$x^{'}$位置处的像素值替换成由公式3.1得到的人手正面图$x$位置处的像素值。这里需要注意我们只是以小拇指作为例子，因此还需要将以上操作运用到检测到的每一个手指或者手掌的边缘。

图3.6分别展示了原始的人手正面图、经过处理后的人手正面图以及将镜像后的背面人手图与处理后的人手正面图叠加后的效果图。
\begin{figure}[htb]
\begin{tabular}{ccc}
\subfigure[]{
\begin{minipage}[c]{0.3\textwidth}
\includegraphics[width=4.2cm]{img/fron.jpg}
\end{minipage}} &
\subfigure[]{
\begin{minipage}[c]{0.3\textwidth}
\includegraphics[width=4.2cm]{img/over_fron.jpg}
\end{minipage}} &
\subfigure[]{
\begin{minipage}[c]{0.3\textwidth}
\includegraphics[width=4.2cm]{img/overlap_dst1.jpg}
\end{minipage}}\\ 
\end{tabular}
\caption{人手正面图: (a) 原始图; (b) 处理图; (c) 叠加图.}
\end{figure}

从图3.6(c)我们可以看出经过处理后的人手正面图可以和镜像后的人手背面图完美重合。

\section{色彩传递}
直接拍摄得到的人手正反面图像因为光照和肤色等原因可能在色彩上有很大差异。如果直接进行纹理融合会使结果显得很不真实，因此我们需要对人手正面图和背面图进行色彩传递。但在介绍算法前我们需要介绍两种将会用到的颜色模型。	

\subsection{RGB颜色模型}
RGB颜色模型是人们使用最多的一种颜色模型。这种模型被广泛的应用于彩色监视器和显示器系统之中。它是采用红(R)、绿(G)、蓝(B)为三基色并通过一定程度的叠加来产生人类所能看到的各种各样的颜色。任意颜色的方程可以表示如下：
\begin{eqnarray}
F=\alpha(R)+\beta(G)+\gamma(B),\qquad 0 \leq \alpha,\beta,\gamma \leq 1
\end{eqnarray}
其中$\alpha$、$\beta$、$\gamma$被称为三色系数，用来对三原色进行混合。

我们可以用一个三维立方体来直观的对RGB颜色空间进行描述\cite{Gonzalez02}，如图3.6所示：

\begin{figure}[htb]
\centering
\includegraphics[width=2.3in, height=2.25in]{../img/cube.eps}
\caption{RGB颜色模型}
\label{fig：graph}
\end{figure} 
图中的原点表示为黑色(0,0,0)，沿着正方形的主对角线依次产生灰度级变化，最终变为白色(1,1,1)。另外别的各点也分别代表不同的颜色，如(0,1,1)代表青色，(1,0,1)代表深红而(1,1,0)代表黄色。对R、G、B进行不同比例的混合就可以产生任意需要的颜色。     

\subsection{$l\alpha\beta$颜色模型}
Ruderman等人\cite{Ruderman98}于1998年提出了这种新的模型，目前还未得到普及。这种颜色模型通过对自然界图片的颜色分布进行统计，使其能够更加符合人类的视觉感知系统。$l\alpha\beta$颜色空间的中$l$通道表示亮度值坐标值、$\alpha$表示黄蓝对立色坐标值而$\beta$则表示红绿对立色坐标值\cite{ZhaoMY08,ZhuoY06}。这种颜色空间因为可以将颜色信息和亮度进行最大限度的分离，因此它极大的降低了各颜色通道之间的相关性，使其具有一定的相互独立性。

$l\alpha\beta$颜色模型可以使我们在不同的颜色通道中进行不同的运算从而能够避免通道的交叉问题。因此这种模型被广泛用于彩色图像处理和色彩传递等问题中。

\subsection{基于$l\alpha\beta$颜色空间的色彩传递}
我们采用Reinhard等人\cite{Reinhard01}的方法通过将图像由$RGB$颜色空间变换到$l\alpha\beta$颜色空间，并在$l\alpha\beta$空间中采用目标图像的均值和方差去代替源图像的均值和方差\cite{LinY01}，其具体步骤如下：

1)首先将图像从RGB颜色空间转换到与设备无关的XYZ颜色空间中去，转换的公式如式3.3所示：

\begin{eqnarray} 
  \begin{small}     %开始数学环境
	\begin{bmatrix}
	  X\\  %第一行元素
	  Y\\  %第二行元素
	  Z\\  %第三行元素
	\end{bmatrix}  
	= 
	\begin{bmatrix}
	  0.5141 & 0.3239 & 0.1604\\
	  0.2651 & 0.6702 & 0.0641\\
	  0.0241 & 0.1288 & 0.8444\\
	\end{bmatrix} 
	\begin{bmatrix}
	  R\\
	  G\\
	  B\\
	\end{bmatrix}
  \end{small}
\end{eqnarray}

2)将XYZ颜色空间转换到LMS锥细胞空间中去，转换的公式如式3.4所示：

\begin{eqnarray} 
  \begin{small}     %开始数学环境
	\begin{bmatrix}
	  L\\  %第一行元素
	  M\\  %第二行元素
	  S\\  %第三行元素
	\end{bmatrix}  
	= 
	\begin{bmatrix}
	  0.3811 & 0.6890 & -0.0787\\
	 -0.2298 & 1.1834 &  0.0464\\
	  0.0000 & 0.0000 &  1.0000\\
	\end{bmatrix} 
	\begin{bmatrix}
	  X\\
	  Y\\
	  Z\\
	\end{bmatrix}
  \end{small}
\end{eqnarray}

3)将3.3式和3.4式合并得：
\begin{eqnarray} 
\begin{small}     %开始数学环境
\begin{bmatrix}
    L\\  %第一行元素
    M\\  %第二行元素
    S\\  %第三行元素
\end{bmatrix}  
= 
\begin{bmatrix}
    0.3811 & 0.5783 & 0.0402\\
    0.1967 & 0.7244 & 0.0782\\
    0.0241 & 0.1288 & 0.8444\\
\end{bmatrix} 
\begin{bmatrix}
	R\\
	G\\
	B\\
\end{bmatrix}
\end{small}
\end{eqnarray}

4)由于图像在LMS颜色空间中的数据分布很不均匀，因此我们需要对$L$,$M$,$S$分别取对数以改善数据相对于坐标轴的对称性，其变换的方式如下：

首先使
\begin{equation}
 \begin{split}
\boldsymbol{L} &= logL \\
\boldsymbol{M} &= logM \\
\boldsymbol{S} &= logS
 \end{split}
\end{equation}

之后旋转LMS颜色空间的坐标轴使其不相关。旋转的方式为：

\begin{eqnarray}       %开始数学环境
\begin{small}
\begin{bmatrix}
    l\\  %第一行元素
    \alpha\\  %第二行元素
    \beta\\  %第三行元素
\end{bmatrix}  
= 
\begin{bmatrix}
    \displaystyle\frac{1}{\sqrt{3}} & 0 & 0\\
    0 & \displaystyle\frac{1}{\sqrt{6}} & 0\\
    0 & 0 & \displaystyle\frac{1}{\sqrt{2}}\\
\end{bmatrix} 
\begin{bmatrix}
    1 & 1 & 1\\
    1 & 1 & -2\\
    1 & -1 & 0\\
\end{bmatrix} 
\begin{bmatrix}
	\boldsymbol{L}\\
	\boldsymbol{M}\\
	\boldsymbol{S}\\
\end{bmatrix}
\end{small}
\end{eqnarray}

5)计算人手背面图像在$l\alpha\beta$颜色空间的均值$\bar{l_{s}},\bar{\alpha_{s}},\bar{\beta_{s}}$，以及在该颜色空间中的方差$\sigma^{l}_{s},\sigma^{\alpha}_{s},\sigma^{\beta}_{s}$.

6)计算人手正面图像在$l\alpha\beta$颜色空间的均值$\bar{l_{t}},\bar{\alpha_{t}},\bar{\beta_{t}}$，以及在该颜色空间中的方差$\sigma^{l}_{t},\sigma^{\alpha}_{t},\sigma^{\beta}_{t}$.

7)以人手背面图为基准，计算经过变换后的人手正面图的$l',\alpha',\beta'$,变换的方式为：
\begin{eqnarray}       %开始数学环境
\begin{bmatrix}
    l'\\  %第一行元素
    \alpha'\\  %第二行元素
    \beta'\\  %第三行元素
\end{bmatrix} 
& = &
\begin{small}
\begin{bmatrix}
\vspace{0.2cm}%这一块要记住怎么弄的
    \displaystyle\frac{\sigma^{l}_{t}}{\sigma^{l}_{s}}& * & (l_{s}-\bar{l_{s}})& +&\bar{l_{t}}\\
\vspace{0.2cm}
    \displaystyle\frac{\sigma^{\alpha}_{t}}{\sigma^{\alpha}_{s}}& * &(\alpha_{s}-\bar{\alpha_{s}})&+&\bar{\alpha_{t}} \\
   \displaystyle\frac{\sigma^{\beta}_{t}}{\sigma^{\beta}_{s}}& * &(\beta_{s}-\bar{\beta_{s}})&+&\bar{\beta_{t}}\\
\end{bmatrix} 
\end{small}
\end{eqnarray}

8)最后分别采用式3.7和式3.5的反变换将人手正面图由$l\alpha\beta$颜色空间变换回RGB颜色空间中去。

最终的效果图如图3.8所示：
\begin{figure}[htb]
\begin{tabular}{ccc}
\subfigure[]{
\begin{minipage}[c]{0.3\textwidth}
\includegraphics[width=4.2cm]{../img/over_back.jpg}
\end{minipage}} &
\subfigure[]{
\begin{minipage}[c]{0.3\textwidth}
\includegraphics[width=4.2cm]{../img/over_fron.jpg}
\end{minipage}} &
\subfigure[]{
\begin{minipage}[c]{0.3\textwidth}
\includegraphics[width=4.2cm]{../img/over_tran.jpg}
\end{minipage}}\\ 
\end{tabular}
\caption{色彩传递: (a) 原始的人手背面图; (b) 原始的人手正面图; (c)
经过色彩传递处理后的人手正面图.}
\end{figure} 

将图3.8(b)和3.8(c)进行对比我们发现色彩传递能够很好的使得处理后的人手正面图和人手背面图颜色非常接近。

\section{正反面顶点分离}
3D模型通常是由许多点组成，点与点之间进行连线组成多边形，并经过纹理贴图等渲染技术生成最终的模型。因此当我们采用人手正反面图像对3D手模型进行纹理贴图时需要将模型的正反面顶点分别提取出来。顶点的提取涉及到计算机图形学中经典的隐藏面消隐技术，这种技术的产生通常是因为我们在三维场景中并不能看到不透明三维物体的全部表面，物体之间因为相互遮挡而使得部分不可见。如果我们还是将全部的多边形进行绘制将会浪费很多计算机资源，并使得显示的三维物体不真实。因此在确定视点之后，我们需要将没有贡献的场景部分删除，而将可见的场景发送至绘制管线。图3.9展示了消隐算法的功能。

\begin{figure}[htb]
\centering
\includegraphics[width=3.8in, height=2.0in]{../img/triangle.jpg}
\caption{消隐算法实例}
\label{fig：graph}
\end{figure} 

这里我们先介绍几种比较常用的隐藏面消隐算法，之后详细介绍我们所使用的正反面顶点分离方法。


\subsection{深度排序算法}

这种算法又被称为画家算法。通常画家在作画时总是先在图纸上涂上背景色，然后画上较远的景物，最后画上较近的景物。通常近的场景会遮挡较远的场景，从而将其覆盖。

采用同样的方法，我们首先对所有多边形按照深度进行排序，并定义深度大的场景优先级低，而深度小的场景优先级高。之后从优先级低的多边形开始逐个进行扫描转换，直到最高优先级的多边形为止。

该算法看似简单，但是需要对不同情况下的多边形以深度为条件进行排序。如果在深度上没有重叠才进行扫描转换。如果有重叠，则需要通过一定的比较来判定是否依然可以进行扫描交换，还是需要对表面进行交换来继续判定。下面以$F$作为需要绘制的面，而以$F^{'}$作为与$F$在深度上重叠而需要与之进行比较的面，其中视点位于z轴正方向无限远处。比较准则如下所示\cite{Donald10}：

(1)两表面在xy坐标平面上投影的包围矩形无重叠。

如图3.10所示：
\begin{figure}[htb]
\centering
\includegraphics[width=2.4in, height=2.3in]{../img/huajia1.jpg}
\caption{两表面在深度上有重叠但在$x$方向无重叠}
\label{fig：graph}
\end{figure} 

从图3.10我们可以看出$F$与$F^{'}$在深度上有重叠，但是他们在$x$方向上无重叠，因此认为两表面无重叠。如果他们在$x$方向上有重叠则需要判断他们在$y$方向上是否有重叠。总而言之，只要他们在任一方向上无重叠就认为两表面无重叠。

(2)相对于观察者而言，面$F$完全位于面$F^{'}$之后。

如图3.11所示：
\begin{figure}[htb]
\centering
\includegraphics[width=2.25in, height=2.25in]{../img/huajia2_n.jpg}
\caption{$F$完全位于$F^{'}$之后}
\label{fig：graph}
\end{figure} 

(3)相对于观察者而言，面$F^{'}$完全位于面$F$之前。

如图3.12所示：
\begin{figure}[htb]
\centering
\includegraphics[width=2.25in, height=2.25in]{../img/huajia3.jpg}
\caption{$F^{'}$完全位于$F$之前}
\label{fig：graph}
\end{figure} 

上述三个条件只要任一条件为真则都不需要继续往下进行判断，将下一重叠表面代替$F^{'}$继续从条件一开始判定即可。若是三个条件均不成立，则需要判定条件4。

(4)两表面在观察平面上投影无重叠。

如图3.13所示：
\begin{figure}[htb]
\centering
\includegraphics[width=2.25in, height=2.25in]{../img/huajia4.eps}
\caption{两表面相交}
\label{fig：graph}
\end{figure} 

上图中两个表面相交，因此不满足条件4。

如果对于与$F$表面在深度上有重叠的所有表面进行以上测试后，只要有一个条件成立则可对$F$进行扫描转换。如果均不成立则需要将$F$与$F^{'}$进行交换并再次执行上述的四个判定条件，直到找到满足条件的面为止。

深度排序算法因为需要对每个点都进行渲染，而忽略了场景中的遮挡因素。因此对于复杂的场景而言，深度排序算法可能会浪费很多的计算机资源。另外若是存在两个或者多个表面相互遮挡的情况时，利用上述判定准则还有可能出现死循环的现象。为了避免此算法的缺陷，科学家们在此基础上研究出了深度缓冲算法，我们将会在下一小节中详细介绍。


\subsection{深度缓存算法}
这种算法是目前最常用的一种消隐算法，其最早由Edwin
Catmull提出。因其简单而易于实现，目前已成为OpenGL所使用的方法，并且被硬件化而存在于许多先进的图形工作站和计算机图形系统中，从而可以快速生成和实时显示需要的图形。

其具体的算法步骤如下：

1)首先定义两个数组分别为深度缓存数组ZB与颜色属性数组CB，并将两个数组分别初始化使得$ZB(i,j)=1.0$，$CB(i,j)=backgroudColor$,这里的$(i,j)$代表屏幕上的像素位置。

2)处理场景中多边形$A$，计算其在点$(i,j)$处的深度值$z$.

3)若$z<ZB(i,j)$，则更新该位置的颜色使得$ZB(i,j)=z$，$CB(i,j)=surfaceColor$.

4)对场景中的所有多边形均执行(2)、(3)两步，最终深度缓存数组ZB中存放的即是可见面的深度值，而颜色属性数组CB存放的就是可见面。

如图3.14所示，最终我们存放的即是F1处的深度值以及颜色值\cite{Donald10}。

\begin{figure}[htb]
\centering
\includegraphics[width=2.0in, height=3.0in]{../img/zbuffer.jpg}
\caption{通过观察面得到F1的深度最小}
\label{fig：graph}
\end{figure} 

深度缓存算法易于实现，算法复杂度为$O{N}$，其中$N$为多边形表面采样点的数目。但是却是一种典型的以空间换取时间的算法。这种算法占用了大量的存储空间，以目前常见的1280*1024分辨率的系统而言，需要2*1280*1024个存储单元，如果我们以$float$型进行数据的存储，则大约需要1000万个字节左右。为了解决此问题我们可以采用每次只存储一行的方式，每计算出一行像素就进行输出，然后再处理下一行\cite{PanYH03}，这种方式虽然能极大的减少存储空间，但是因为它忽略垂直方向上点的相关性，因此得到的结果并不十分了理想。

另外在图3.14中，当我们判断出F2的深度值小于F3的深度后，我们以F2的深度代替F3的深度值，并更新$(i,j)$处的像素值。但之后我们发现F1的深度值比F1还要小，这样对于F2我们就做了一些无用的计算。因此目前有些图形软件可以让我们通过选择测试深度范围的方式来排除一些不需要的计算。

OpenGL支持深度缓存。在初始化显示模式前首先要指定将会使用深度缓存：

$glutInitDisplayMode(GLUT\_DEPTH | GLUT\_RGB)$;

在对图像进行渲染前还需要启用深度测试：

$glEnable(GL\_DEPTH\_TEST)$;

启用深度缓存后需要对深度缓存进行初始化：

$glClear(GL\_COLOR\_BUFFER\_BIT | GL\_DEPTH\_BUFFER\_BIT)$;

而关闭深度缓存为：

$glDisable(GL\_DEPTH\_TEST)$;

\subsection{光线跟踪算法}
光线跟踪(Raytracing)算法可以看作深度缓存算法的一个变体，其最早由Arthur
Appel在1968年提出。其基本思想是由观察平面上的所有像素都射出一条光线，计算出每个光线与场景中对象的所有交点，其中离像素点最近的非透明表面即为我们需要进行渲染的可见面。算法原理如图3.15所示：
\begin{figure}[htb]
\centering
\includegraphics[width=2.55in, height=2.5in]{../img/light.eps}
\caption{光线跟踪算法}
\label{fig：graph}
\end{figure} 

光线跟踪算法的基本步骤可简单描述如下\cite{ZhangYF07}：

1)沿着视点和观察平面上的所有像素点出发作一入射线。

2)将每个入射线与场景中的所有对象求交。

3)对每根入射线，若求得交点，则将交点按照深度大小进行排序，取出离观察平面最近的表面上的颜色。若无交点，则取出背景色。

4)将取出的颜色取代像素的颜色即得到最终渲染的结果。

光线跟踪算法其作用并不仅仅是计算得到可见面。其更大的作用是沿着到达视点的光线的反方向进行跟踪，通过计算光线在物体上的反射和折射，从而计算出物体上的总光源。这为渲染三维场景的反射和折射效果提供了一种简单有效的方法。这里我们不再详细讨论。

计算物体可见面除了以上三种方法外还有区域排序算法、扫描线算法和BSP算法等。虽然这些算法的基本思路各不相同，但它们大多都是采用排序和连贯性的方法来提高算法的效率。我们不再一一介绍。

\subsection{顶点分离}

正反面顶点的提取需要利用隐藏面消隐技术。当人手正面朝向观察者时将背面顶点组成的多边形删除，而当人手背面朝向观察者时将正面顶点组成的多边形删除。这样即可分别提取正反面的顶点，从而便于以后纹理的映射。不过考虑到人手的3D模型可看做是一个凸多边形，并且对3D模型进行渲染时是以三角形面片为单元进行\cite{Shreiner07}。针对这一特性我们能设计一种更简单的方案来提取前后点。其具体步骤如下：

1)使人手背/正面朝向观察者，将所有顶点均标记为正。

2)对任一三角形面片，判断剩余顶点是否位于三角形之内。如果在则进一步判断它的深度是否小于组成三角面片中任意顶点的深度。如果是则认为此顶点是属于非背/正面顶点，将其标记为负。

3)对所有三角形面片均进行2)中的处理，最终得到的标记为正的顶点就是人手背/正面的顶点。

这里的关键是第二步，我们需要判断一个顶点是否在一个三角形内，判断的方法也很简单，如图3.16所示：
\begin{figure}[htb]
\centering
\includegraphics[width=2.05in, height=2.0in]{../img/tran.jpg}
\caption{判断顶点是否在三角形之内}
\label{fig：graph}
\end{figure} 

计算出三角形三条边所在的直线方程，如计算出$AB$的直线方程$ax+by+c=0$后，将$d$的坐标$(x_{d},y_{d})$和$C$的坐标$(x_{C},y_{C})$分别带入$AB$的方程，如果有$(ax_{d}+by_{d}+c)*(ax_{C}+by_{C}+c)>0$说明两者同号，也即位于$AB$直线的同一侧。同样对$AC$、$BC$进行判断，如果三条直线均与$d$点在同一侧则认为其在三角形内部。

因为需要对每个三角形都遍历所有顶点，其算法复杂度为$O(M*N)$，其中$M$为三角形个数而$N$为顶点个数。因此我们可以简化判断的方法，采用包围体的设计思想\cite{BoxWeiji01}，对每个三角形都用一个四方形的包围框围着，如图3.17所示：

\begin{figure}[htb]
\centering
\includegraphics[width=4.5in, height=1.5in]{../img/tranPoint.jpg}
\caption{包围盒}
\label{fig：graph}
\end{figure} 

3.17(a)中顶点未落入包围框内，因此不对其进行处理。而在3.17(b)与3.17(c)中顶点落入包围框内，因此还需要判断其是否在三角形内部。而判断一个顶点是否在包围框内只需比较将其坐标与包围框的最小与最大坐标比较即可。

另外还需要注意的是我们在步骤二中标记为负的点并不能直接作为人手正/背面上的顶点。比如对手背处理后那些被标记为负的点只能算是人手正面点的一部分，因为在人手正面和人手背面的接缝处这些点既属于正面点，又属于背面点。因此需要把这些点也包含进去。我们采用的方式是忽略标记为负的点，将手在三维空间中旋转$180^{0}$然后做和上面相同的处理即可。

最终提取出的正反面顶点如图3.18所示：
\begin{figure}[htb]
\begin{tabular}{ccc}
\subfigure[]{
\begin{minipage}[c]{0.3\textwidth}
\includegraphics[width=4.2cm]{../img/vertex_all.jpg}
\end{minipage}} &
\subfigure[]{
\begin{minipage}[c]{0.3\textwidth}
\includegraphics[width=4.2cm]{../img/vertex_back1.jpg}
\end{minipage}} &
\subfigure[]{
\begin{minipage}[c]{0.3\textwidth}
\includegraphics[width=4.2cm]{../img/vertex_fron1_1.jpg}
\end{minipage}}\\ 
\end{tabular}
\caption{顶点的渲染: (a) 所有顶点; (b) 背面顶点; (c) 正面顶点.}
\end{figure}

\section{纹理映射}
提取出每个点以后我们需要使用映射函数将其坐标值映射到纹理空间去，并通过得到的纹理空间值从纹理中得到相应的颜色值，这个过程就被称为纹理映射。而纹理映射的过程实际上与将三维空间中的物体投影到观察平面的过程是极其相似的。因此我们首先介绍物体的投影过程，然后将其直接应用到我们的纹理映射当中去。

通常我们在对一个三维对象进行显示时首先需要选择裁剪区域，裁剪区域的作用是限制三维对象的显示范围，只有处于裁剪区域内的对象才会进行投影并最终显示在我们的观察视口之中，而处于裁剪区域外的对象则不进行显示。其裁剪过程如图3.19所示：

\begin{figure}[htb]
\centering
\includegraphics[width=1.8in, height=1.8in]{../img/caijian1.jpg}
\caption{裁剪对象}
\label{fig：graph}
\end{figure} 

我们的三维对象是面片$ABC$，但是经过裁剪区域裁剪后变成了$ABde$。因为只有在裁剪区域的三维对象才会进行投影，因此裁剪区域又被称作视景体。裁剪操作不仅仅是裁剪掉无用的对象，因为我们把需要的三维场景放入到了一个标准的立方体中，这使得我们在以后的坐标变化上更加简单而有效率。

\subsection{投影变换}
经过裁剪操作后可以将我们感兴趣的场景投影到某个简单体或某种平面上去。投影变换实际上是一种坐标变换的过程。本文选择的投影体是一个单位立方体，这将使得我们的坐标变换操作更加简单和统一。甚至有一些文献把裁剪操作放到投影变换以后进行，因为在单位立方体中进行裁剪操作更加容易。

目前常用的投影的方式主要分为两种，分别是正交投影和透视投影。下面我们将会一一介绍。

\subsubsection{正交投影}
正交投影是指投影线垂直于投影平面的一种投影方式，因此也被称为平行投影。这种投影方式因为可以精确的描绘出物体的长度和角度，因此被广泛应用于工程和建筑绘图之中。

正交投影的裁剪体通常用一个长方体包围盒来表示，而包围盒的上、下、左、右、前、后则分别用$t,b,l,r,f,n$表示。我们需要将包围盒变换成规范化观察体(normalized
view volume)，这就是我们上面所提到的单位立方体，其每一维的坐标都是从$-1$到$1$。使用规范化观察体可以让我们更加有效的进行裁剪操作，尤其当我们采用硬件来实现裁剪操作时这种方式的优势更加明显，目前大部分软件包都是使用单位立方体作为规范化观察体。其变换过程如图3.20所示\cite{Tomas02}：

\begin{figure}[htb]
\centering
\includegraphics[width=5.0in, height=2.0in]{../img/zhengjiao1.jpg}
\caption{正交投影转换过程}
\label{fig：graph}
\end{figure} 

该正交变换可用下式来表示：
\begin{eqnarray}       %开始数学环境
T& = &
\begin{small}
\begin{bmatrix}
\vspace{0.2cm}
    \displaystyle\frac{2}{r-l} & 0 & 0 & 0\\  %第一行元素
\vspace{0.2cm}
    0 & \displaystyle\frac{2}{t-b} & 0 & 0\\  %第二行元素
\vspace{0.2cm}
    0 & 0 & \displaystyle-\frac{2}{f-n} & 0\\  %第三行元素
    0 & 0 & 0 & 1\\%第si行元素
\end{bmatrix}
\end{small}
\begin{bmatrix}
\vspace{0.2cm}
    1 & 0 & 0 & \displaystyle-\frac{r+l}{2}\\  %第一行元素
\vspace{0.2cm}
    0 & 1 & 0 & \displaystyle-\frac{t+b}{2}\\  %第二行元素
\vspace{0.2cm}
    0 & 0 & 1 & \displaystyle-\frac{f+n}{2}\\  %第三行元素
    0 & 0 & 0 & 1\\%第si行元素
\end{bmatrix}  \notag \\
&= & 
\begin{small}
\begin{bmatrix}
\vspace{0.2cm}
    \displaystyle\frac{2}{r-l} & 0 & 0 & \displaystyle-\frac{r+l}{r-l}\\  %第一行元素
\vspace{0.2cm}
    0 & \displaystyle\frac{2}{t-b} & 0 & \displaystyle-\frac{t+b}{t-b}\\  %第二行元素
    0 & 0 & \displaystyle-\frac{2}{f-n} & \displaystyle-\frac{f+n}{f-n}\\  %第三行元素
    0 & 0 & 0 & \displaystyle1\\%第si行元素
\end{bmatrix} 
\end{small}
\end{eqnarray}

该矩阵是由平移矩阵和缩放矩阵相乘得到的。通过此矩阵即可完成视景体从世界坐标系到规范化观察体所在坐标系的转换。这时我们再进行裁剪操作，将需要绘制的几何体进行裁剪，并将单位立方体通过背景面消除等操作映射到最终的屏幕上，从而完成三维物体的绘制。

目前许多图形化软件已经包含了能够处理正交投影的函数，如在OpenGL中正交矩阵的生成函数是$glOrtho$以及DirextX中的D3DXMatrix
OrthoOffCenterLH。

\subsubsection{透视投影}
尽管正交投影较易生成并且可以保持物体原有的比例，但是却丧失了物体的真实感特征。比如两条无限长的铁轨，如果采用正交投影，则我们所看到的依然是两条平行的直线。但是实际上在无限远处我们所能看到的两条铁轨应该相交于一点，这一点就被称为灭点。而采用透视投影则可以达到这样的效果，因为它更加符合人类感知世界的过程：相同大小的物体距离观察平面越远则投影后就越小。

透视投影的裁剪体通常用一个棱台观察体来表示，而观察体的上、下、左、右、前、后则依然采用$t,b,l,r,f,n$表示。将棱台观察体变换为规范化观察体的过程如图3.21所示：
\begin{figure}[htb]
\centering
\includegraphics[width=5.0in, height=2.0in]{../img/toushi.jpg}
\caption{透视投影转换过程}
\label{fig：graph}
\end{figure} 

透视投影的变换通常是不可逆的，其变换可用下式来表示：
\begin{eqnarray}       %开始数学环境
T = 
\begin{small}
\begin{bmatrix}
\vspace{0.2cm}
    \displaystyle\frac{2n}{r-l} & 0 & \displaystyle\frac{r+l}{r-l} & 0\\  %第一行元素
\vspace{0.2cm}
    0 & \displaystyle\frac{2n}{t-b} & \displaystyle\frac{t+b}{t-b} & 0\\  %第二行元素
	0 & 0 & \displaystyle-\frac{f+n}{f-n} & \displaystyle-\frac{2fn}{f-n}\\  %第三行元素
    0 & 0 & -1 & 0\\%第si行元素
\end{bmatrix} 
\end{small}
\end{eqnarray}

这个矩阵就被称为透视矩阵，它也是由平移矩阵和缩放矩阵再加上透视变换得到的。通过此矩阵我们就可以将棱台观察体转换为规范化单位立方体，从而利于我们的裁剪操作。

OpenGL中有两个函数可以实现透视投影，分别是$glFrustum$函数与$gluPerspective$函数，通常我们更多的使用第二个函数，因为它的参数更加直观。在使用这两个函数前需要先调用$glMatrixMode(GL\_PROJECTION)$。

\subsection{视口变换}
无论是正交投影还是透视投影都是通过平移和缩放等操作将一个平行六面体变成了一个单位立方体。比如一个长宽比为2的场景经过正交变换或透视变换后长宽比均变为了1,其对x轴和y轴方向分别做了不同程度的拉伸，把任意的三维场景都变换到一个固定大小的空间中，这必然会造成物体的形变。为了解决此问题，我们可以通过视口变换再将正方体的近裁剪面(可看做观察平面)映射到长宽比为2的视口上，这样就可以将形变进行矫正。

其变换过程如图3.22所示：
\begin{figure}[htb]
\centering
\includegraphics[width=5.6in, height=1.8in]{../img/shikou.jpg}
\caption{视口变换}
\label{fig：graph}
\end{figure} 

从图3.22我们也可看出视口变换实际上也是屏幕映射的过程，经过投影变换后的物体在单位立方体内的坐标依然是三维的，因此我们需要将其经过背影面消隐等过程提取出每个对应屏幕坐标位置处的颜色，从而将其在屏幕中显示出来。OpenGL中处理视口变换的函数是$glViewport$。

\subsection{一般纹理贴图}
纹理贴图实际上就是对物体表面属性进行物理建模的过程。为获得物体在纹理上的对应颜色值，首先需要通过一个或多个投影函数将物体在空间中的位置变换到纹理空间中去，然后使用纹理空间对应位置的颜色值来代替物体的表面颜色。这里我们采用一个例子来详细描述纹理映射的过程，具体过程如图3.23所示\cite{Tomas02}：

\begin{figure}[htb]
\centering
\includegraphics[width=3.0in, height=2.0in]{../img/wenliyingshe.jpg}
\caption{纹理映射过程}
\label{fig：graph}
\end{figure} 

假设物体在空间中的位置为(-100,20,40)，这里我们使用正交投影函数将其投影到纹理空间中。通常为了便于管理，我们将纹理坐标值的范围规定为0到1\cite{Everitt01}，而不考虑纹理的重复与截取等特殊情况。因此对于二维纹理来说，纹理坐标按照逆时针方向依次是(0,0)、(1,0)、(1,1)、(0,1)。这里我们假设投影到纹理空间后的坐标为(0.5,0.1)，并假设纹理图像的分辨率为1024*768。因此可得真实的坐标值为(512,76)，在此位置处找到纹理图像中的颜色值为(129,152,148)。这个颜色值即可用来代替物体的表面颜色。

\subsection{对手贴纹理}
对手贴纹理的过程实际上就是对3D人手模型进行投影的过程，只不过这里我们要对投影的位置做出较高的要求，而不只是将其投影到任意可见的位置。我们希望投影到屏幕上的模型能够恰好与拍摄得到的人手正反面纹理图相重合。相对于人手的面而言其厚度比较小，因此这里我们采用正交投影就能达到目的。

上面我们已经讨论过纹理图的位置在0到1之间，而物体在单位立方体中的坐标为-1到1，因此我们需要对3.9式做出调整，将其在x、y、z方向上均平移$1/2$个单位，并在三个方向上缩放为原来的$1/2$，调整的方式见3.11式：
\begin{eqnarray}       %开始数学环境
  T^{'}& = &
\begin{small}
\begin{bmatrix}
\vspace{0.2cm}
    \displaystyle\frac{1}{2} & 0 & 0 & \displaystyle\frac{1}{2}\\  %第一行元素
\vspace{0.2cm}
    0 & \displaystyle\frac{1}{2} & 0 & \displaystyle\frac{1}{2}\\  %第二行元素
\vspace{0.2cm}
    0 & 0 & \displaystyle\frac{1}{2} & \displaystyle\frac{1}{2}\\  %第三行元素
    0 & 0 & 0 & 1\\%第si行元素
\end{bmatrix}
\end{small}
\begin{bmatrix}
\vspace{0.2cm}
    \displaystyle\frac{2}{r-l} & 0 & 0 & \displaystyle-\frac{r+l}{r-l}\\  %第一行元素
\vspace{0.2cm}
    0 & \displaystyle\frac{2}{t-b} & 0 & \displaystyle-\frac{t+b}{t-b}\\  %第二行元素
\vspace{0.2cm}
    0 & 0 & \displaystyle-\frac{2}{f-n} & \displaystyle-\frac{f+n}{f-n}\\  %第三行元素
    0 & 0 & 0 & \displaystyle1\\%第si行元素
\end{bmatrix}  \notag \\
&= & 
\begin{small}
\begin{bmatrix}
\vspace{0.2cm}
    \displaystyle\frac{1}{r-l} & 0 & 0 & \displaystyle-\frac{l}{r-l}\\  %第一行元素
\vspace{0.2cm}
    0 & \displaystyle\frac{1}{t-b} & 0 & \displaystyle-\frac{b}{t-b}\\  %第二行元素
\vspace{0.2cm}
    0 & 0 & \displaystyle-\frac{1}{f-n} & \displaystyle-\frac{n}{f-n}\\  %第三行元素
    0 & 0 & 0 & \displaystyle1\\%第si行元素
\end{bmatrix} 
\end{small}
\end{eqnarray}

通过对每个顶点右乘3.11式，即可得到每个顶点所对应的纹理坐标。因此我们的目的就是计算$t,b,l,r,f,n$这六个参数，考虑到前面我们已经将人手的正面和背面顶点分离开来了，因此我们可以不用计算$f$和$n$这两个参数。我们将会在下面给出计算$t,b,l,r$参数的方法。

首先给出背面人手的纹理图像以及背面人手的模型，如图3.24所示：

\begin{figure}[htb]
\begin{tabular}{cc}
~~~~\includegraphics[width=2.2in, height=2.2in]{../img/image_dist1.jpg}&
~~~~~~~\includegraphics[width=2.2in, height=2.2in]{../img/model_dist1.jpg}\\
(a)& (b)
\end{tabular}
\caption{对两张图进行标记: (a)标记纹理图 (b)标记模型图.}
\end{figure}
图3.24(a)中$A,B,C$分别代表小拇指、大拇指和中指的最外边顶点，$a,c,d$则代表$A,B,C$点与边缘的距离，$b_{1}$代表$A$点到$B$点的横向距离。图3.24(b)中的标记点和图3.24(a)的标记点相似，只不过我们用$l,r,l,t$来代替上下左右四个边界。

从图3.24中我们可以看出$a,b_{1},c,d,b^{'}_{1}$是已知的，并且有：
\begin{eqnarray}
  \frac{b_{1}}{b^{'}_{1}}=\frac{a}{a^{'}}=\frac{c}{c^{'}}=\frac{d}{d^{'}} 
\end{eqnarray}

从上式中我们即可求出$a^{'},c^{'},d^{'}$，进而可以得到$l,r,t$：
\begin{eqnarray}
l&=&x_{A^{'}}-a'\notag \\
r&=&x_{B^{'}}+c'\\
t&=&y_{C^{'}}+d'\notag
\end{eqnarray}
其中$x_{A'}$和$x_{B'}$ 分别是$A'$和$B'$的横坐标，$y_{C'}$则是$C'$的纵坐标。

为了使投影后的3D人手模型能够和拍摄的人手纹理图像重合，我们需要满足式3.14：
\begin{eqnarray}
\frac{t-b}{r-l} = \frac{H}{W}
\end{eqnarray}
其中$W$和$H$分别代表纹理图像的宽度和高度，最终我们可以从上式中求得$b$：
\begin{eqnarray}
b = t-\frac{H}{W}*(r-l)
\end{eqnarray}

图3.25是经过纹理贴图后的人手模型：
\begin{figure}[htb]
\begin{tabular}{cc}
~~~~~~~~~~~~~~~~\includegraphics[width=3.6cm, height=5.0cm]{../img/model_back_tex1.jpg}&
~~~~~~~~~~~~~~~\includegraphics[width=3.6cm, height=5.0cm]{../img/model_front_tex.jpg}\\
~~~~~~~~~~~~~~~~(a)& ~~~~~~~~~~~~~~~(b)
\end{tabular}
\caption{纹理贴图后的人手模型: (a)模型背面; (b)模型正面.}
\end{figure}

对比图3.3(b)和3.25(a)可以看出经过纹理贴图后的模型能够产生更加逼真的效果。

\section{接缝移除}
尽管前面我们已经对人手正面图像做了色彩传递，但是因为拍摄时在边缘处因为光照上有很大差异，因此如果直接通过两张图像对人手进行渲染，在边缘处依然会产生很严重的虚拟接缝。图3.26展示了手指处的接缝：
\begin{figure}[htb]
\centering
\includegraphics[width=2.2in, height=2.0in]{../img/pre_seam.jpg}
\caption{手指处的虚拟接缝}
\label{fig：graph}
\end{figure} 

从图中我们可以看到中指出有明显的虚拟接缝。

为了去除接缝，我们采用一定的着色方式。在介绍具体方法前我们需要先介绍两种着色方式\cite{Fshill04}。

\subsection{平面着色}
平面着色的原理比较简单，通常当光源离面片很远时，面片上不同顶点的漫反射分量很小，可近似认为面片上的每个像素均具有同一种颜色。因此虽然我们在图形学渲染管线中为会一个面片的各个顶点都赋上一个颜色，但是采用平面着色我们只会选取其中一个顶点的颜色来作为整个面片的颜色。

采用这种着色方式并不会为我们带来真实的渲染效果，但是因为其快速的运算速度，因此被广泛用于速度大于细致度的场景之中。OpenGL可以通过$glShadeModel(GL\_FLAT)$来指定着色方式为平面着色。

图3.27给出了使用平面着色对球体进行渲染的效果图：

\begin{figure}[htb]
\centering
\includegraphics[width=2.05in, height=2.0in]{../img/ball1.jpg}
\caption{平面着色渲染球体}
\label{fig：graph}
\end{figure} 

从图中我们可以清晰的看出整个球体呈现马赫带现象，但实际上我们所需要的球体应该是平滑的，而现在在每个面片都是同一种颜色，因此出现这种现象。为了解决此问题，研究者们又研究了一种平滑着色的方式，我们将在下一小节中详细讨论。

\subsection{平滑着色}
这种着色方式并不是使同一面片具有一种颜色，而是通过对不同点的颜色进行线性插值，从而使整个面片显示出平滑的渐变色。平滑着色主要有两种方法，分别是Gouraud着色法和Phong着色法。第二种方法能够产生更加逼真的效果，但是它的运算复杂度和运算时间均大大高于第一种，因此在这里我们并不做讨论，我们重点讨论Gouraud着色法。

Gouraud着色法又被称为高洛德着色法，它可以使得面片中的任一个像素都具有不同的颜色值，这样就能够弱化相邻面片之间的颜色差异。我们以一三角形面片为例，如图3.28所示：

\begin{figure}[htb]
\centering
\includegraphics[width=2.2in, height=2.0in]{../img/gouraud.jpg}
\caption{Gouraud着色法}
\label{fig：graph}
\end{figure} 
三角面片的三个顶点为1,2,3,其坐标分别为$(d_{1},c_{1}),(d_{2},c_{2}),(d_{3},c_{3})$，这里的$d$代表位置，而$c$代表颜色。为了求出5的颜色值我们需要首先求出同一扫描线上4和6的颜色值，其中4和6的颜色值计算公式如下：
\begin{eqnarray}
  c_{4}=c_{1}+(c_{2}-c_{1})\times \frac{d_{4}-d_{1}}{d_{2}-d_{1}}\\
  c_{6}=c_{3}+(c_{2}-c_{3})\times \frac{d_{6}-d_{3}}{d_{2}-d_{3}}
\end{eqnarray}
从而可以得到5的颜色值：
\begin{eqnarray}
  c_{5}=c_{4}+(c_{6}-c_{4})\times \frac{d_{5}-d_{4}}{d_{6}-d_{4}}
\end{eqnarray}

另外也可以得出在同一扫描线上相邻像素的颜色差值为$\frac{c_{6}-c_{4}}{d_{6}-d_{4}}$，这是一个常数，通过采用增量计算可以提高计算效率。

图3.29是采用平滑着色渲染的球体：

\begin{figure}[htb]
\centering
\includegraphics[width=2.05in, height=2.0in]{../img/ball2.jpg}
\caption{平滑着色渲染球体}
\label{fig：graph}
\end{figure} 
可以看出虽然平滑着色的处理算法比平面着色多了一些计算，但是经过Gouraud着色法处理后的球体更加平滑了，我们很难看出面片的边，取而代之的是面片间平滑过度的颜色。另外OpenGL也实现了这种着色方式，通过$glShadeModel(GL\_SMOOTH)$即可调用Gouraud着色。

\subsection{基于平滑着色去除接缝}
虚拟接缝通常只存在与两张图片的拼接之处，因此我们只需针对拼接处的顶点采用平滑着色的方式即可。我们处理的方式大致思想为：

1)对人手背面所有顶点依然采用纹理贴图的方式进行处理。而人手正面并不全部采用纹理贴图，而是提取出最外层顶点以及其最临近的次外层顶点，提取的结果如图3.30所示：

\begin{figure}[htb]
\centering
\includegraphics[width=2.19in, height=2.2in]{img/red.jpg}
\caption{提取最外层和次外层顶点}
\label{fig：graph}
\end{figure}

2)对最外层顶点置予背面人手接缝处的颜色，次外层顶点置予正面人手对应位置的颜色。而由这些顶点所组成的三角面片中像素的颜色则采用平滑着色的方式计算得到。

最终我们得到经平滑着色处理后的虚拟接缝如图3.31：
\begin{figure}[htb]
\centering
\includegraphics[width=2.2in, height=2.0in]{../img/post_seam.jpg}
\caption{去除虚拟接缝后的效果图}
\label{fig：graph}
\end{figure} 

对比图3.26和图3.31可以看出，通过对人手模型的外轮廓采用平滑着色处理，能够较好的去除虚拟接缝。

\section{本章小结}
本章主要描述了为人手模型贴纹理的方法，为模型贴上纹理可以更真实的反应物体的本质特征。首先需要对拍摄得到的正面图像进行调整，使其可以和背面图像的镜像相重合。由于拍摄的原因，需要对正面图像进行色彩传递，从而使两张图像颜色接近。因为需要将正面顶点映射到正面图像而背面顶点映射到背面图像，因此需要分别提取出正反面顶点。为了使人手模型经过投影后能够和纹理图像完美重合，我们需要选择合适的裁剪框以及投影函数。直接采用两张图像进行纹理贴图会在交汇处产生明显的虚拟接缝，可以采用平滑着色的方式对其进行去除。产生逼真的人手模型之后我们需要让它像真实的人手一样能够变换出各种手势，骨骼动画可以帮我们做到这一点。下一章我们将详细介绍通过骨骼动画实现人机交互的方法。










